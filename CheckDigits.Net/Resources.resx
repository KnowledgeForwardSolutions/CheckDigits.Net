<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbaRtnAlgorithmDescription" xml:space="preserve">
    <value>American Bankers Association Routing Transit Number algorithm with weights 3, 7 and 1</value>
  </data>
  <data name="AbaRtnAlgorithmName" xml:space="preserve">
    <value>ABA RTN</value>
  </data>
  <data name="AlgorithmDescriptionIsEmptyMessage" xml:space="preserve">
    <value>Algorithm description may not be null, String.Empty or all whitespace characters</value>
  </data>
  <data name="AlgorithmNameIsEmptyMessage" xml:space="preserve">
    <value>Algorithm name may not be null, String.Empty or all whitespace characters</value>
  </data>
  <data name="AlphanumericMod97_10AlgorithmDescription" xml:space="preserve">
    <value>Variation of ISO/IEC 7064 MOD 97-10 algorithm with alphabetic characters (A-Z) mapped to integers (10-35)</value>
  </data>
  <data name="AlphanumericMod97_10AlgorithmName" xml:space="preserve">
    <value>AlphanumericMod97_10</value>
  </data>
  <data name="CusipAlgorithmDescription" xml:space="preserve">
    <value>CUSIP Algorithm</value>
  </data>
  <data name="CusipAlgorithmName" xml:space="preserve">
    <value>CUSIP</value>
  </data>
  <data name="DammAlgorithmDescription" xml:space="preserve">
    <value>Damm's quasigroup algorithm</value>
  </data>
  <data name="DammAlgorithmName" xml:space="preserve">
    <value>Damm</value>
  </data>
  <data name="FigiAlgorithmDescription" xml:space="preserve">
    <value>FIGI Algorithm</value>
  </data>
  <data name="FigiAlgorithmName" xml:space="preserve">
    <value>FIGI</value>
  </data>
  <data name="GetCheckCharacterValueOutOfRangeMessage" xml:space="preserve">
    <value>Check digit value is out of range for the character domain</value>
  </data>
  <data name="IbanAlgorithmDescription" xml:space="preserve">
    <value>IBAN algorithm - ISO/IEC 7064 MOD 97-10 algorithm with alphabetic characters (A-Z) mapped to integers (10-35)</value>
  </data>
  <data name="IbanAlgorithmName" xml:space="preserve">
    <value>IBAN (International Bank Account Number)</value>
  </data>
  <data name="Icao9303AlgorithmDescription" xml:space="preserve">
    <value>ICAO 9303 algorithm - modulus 10 algorithm used by ICAO (Internation Civil Aviation Organization) machine readable travel documents</value>
  </data>
  <data name="Icao9303AlgorithmName" xml:space="preserve">
    <value>Icao9303</value>
  </data>
  <data name="Icao9303MachineReadableVisaAlgorithmDescription" xml:space="preserve">
    <value>IACO 9303 Algorithm for Machine Readable Visas</value>
  </data>
  <data name="Icao9303MachineReadableVisaAlgorithmName" xml:space="preserve">
    <value>IACO 9303 Machine Readable Visa</value>
  </data>
  <data name="Icao9303SizeTD1AlgorithmDescription" xml:space="preserve">
    <value>IACO 9303 Algorithm for Machine Readable Documents Size TD1</value>
  </data>
  <data name="Icao9303SizeTD1AlgorithmName" xml:space="preserve">
    <value>IACO 9303 Document Size TD1</value>
  </data>
  <data name="Icao9303SizeTD2AlgorithmDescription" xml:space="preserve">
    <value>IACO 9303 Algorithm for Machine Readable Documents Size TD2</value>
  </data>
  <data name="Icao9303SizeTD2AlgorithmName" xml:space="preserve">
    <value>IACO 9303 Document Size TD2</value>
  </data>
  <data name="Icao9303SizeTD3AlgorithmDescription" xml:space="preserve">
    <value>IACO 9303 Algorithm for Machine Readable Documents Size TD3</value>
  </data>
  <data name="Icao9303SizeTD3AlgorithmName" xml:space="preserve">
    <value>IACO 9303 Document Size TD3 </value>
  </data>
  <data name="IsanAlgorithmDescription" xml:space="preserve">
    <value>Variation of ISO/IEC 7064 MOD 37,36 for ISAN values formatted as human readable strings</value>
  </data>
  <data name="IsanAlgorithmName" xml:space="preserve">
    <value>ISAN (International Standard Audiovisual Number)</value>
  </data>
  <data name="IsinAlgorithmDescription" xml:space="preserve">
    <value>Variation of the Luhn algorithm that supports alphanumeric characters</value>
  </data>
  <data name="IsinAlgorithmName" xml:space="preserve">
    <value>ISIN (International Securities Identity Number)</value>
  </data>
  <data name="Iso6346AlgorithmDescription" xml:space="preserve">
    <value>ISO 6346 algorithm</value>
  </data>
  <data name="Iso6346AlgorithmName" xml:space="preserve">
    <value>ISO 6346</value>
  </data>
  <data name="Iso7046AlphabetIsNull" xml:space="preserve">
    <value>Alphabet may not be null</value>
  </data>
  <data name="Iso7064Mod11_10AlgorithmDescription" xml:space="preserve">
    <value>ISO/IEC 7064 hybrid system check digit algorithm with modulus 10</value>
  </data>
  <data name="Iso7064Mod11_10AlgorithmName" xml:space="preserve">
    <value>ISO/IEC 7064 MOD 11,10</value>
  </data>
  <data name="Iso7064Mod11_2AlgorithmDescription" xml:space="preserve">
    <value>ISO/IEC 7064 check digit algorithm with modulus 11 and radix 2</value>
  </data>
  <data name="Iso7064Mod11_2AlgorithmName" xml:space="preserve">
    <value>ISO/IEC 7064 MOD 11-2</value>
  </data>
  <data name="Iso7064Mod1271_36AlgorithmDescription" xml:space="preserve">
    <value>ISO/IEC 7064 check digit algorithm with modulus 1271 and radix 36</value>
  </data>
  <data name="Iso7064Mod1271_36AlgorithmName" xml:space="preserve">
    <value>ISO/IEC 7064 MOD 1271-36</value>
  </data>
  <data name="Iso7064Mod27_26AlgorithmDescription" xml:space="preserve">
    <value>ISO/IEC 7064 hybrid system check digit algorithm with modulus 26</value>
  </data>
  <data name="Iso7064Mod27_26AlgorithmName" xml:space="preserve">
    <value>ISO/IEC 7064 MOD 27,26</value>
  </data>
  <data name="Iso7064Mod37_2AlgorithmDescription" xml:space="preserve">
    <value>ISO/IEC 7064 check digit algorithm with modulus 37 and radix 2</value>
  </data>
  <data name="Iso7064Mod37_2AlgorithmName" xml:space="preserve">
    <value>ISO/IEC 7064 MOD 37-2</value>
  </data>
  <data name="Iso7064Mod37_36AlgorithmDescription" xml:space="preserve">
    <value>ISO/IEC 7064 hybrid system check digit algorithm with modulus 36</value>
  </data>
  <data name="Iso7064Mod37_36AlgorithmName" xml:space="preserve">
    <value>ISO/IEC 7064 MOD 37,36</value>
  </data>
  <data name="Iso7064Mod661_26AlgorithmDescription" xml:space="preserve">
    <value>ISO/IEC 7064 check digit algorithm with modulus 661 and radix 26</value>
  </data>
  <data name="Iso7064Mod661_26AlgorithmName" xml:space="preserve">
    <value>ISO/IEC 7064 MOD 661-26</value>
  </data>
  <data name="Iso7064Mod97_10AlgorithmDescription" xml:space="preserve">
    <value>ISO/IEC 7064 check digit algorithm with modulus 97 and radix 10</value>
  </data>
  <data name="Iso7064Mod97_10AlgorithmName" xml:space="preserve">
    <value>ISO/IEC 7064 MOD 97-10</value>
  </data>
  <data name="Iso7064ModulusOutOfRange" xml:space="preserve">
    <value>Modulus must be greater than one</value>
  </data>
  <data name="Iso7064RadixOutOfRange" xml:space="preserve">
    <value>Radix must be greater than one</value>
  </data>
  <data name="LineSeparatorInvalidValueMessage" xml:space="preserve">
    <value>Value must be a valid member of the LineSeparator enumeration (None, Crlf or Lf)</value>
  </data>
  <data name="LuhnAlgorithmDescription" xml:space="preserve">
    <value>Luhn algorithm - modulus 10 algorithm with weight 2 applied to every odd position character</value>
  </data>
  <data name="LuhnAlgorithmName" xml:space="preserve">
    <value>Luhn</value>
  </data>
  <data name="Modulus10_13AlgorithmDescription" xml:space="preserve">
    <value>Modulus10_13 - modulus 10 algorithm with weights 1 and 3</value>
  </data>
  <data name="Modulus10_13AlgorithmName" xml:space="preserve">
    <value>Modulus10_13</value>
  </data>
  <data name="Modulus10_1AlgorithmDescription" xml:space="preserve">
    <value>Modulus 10 algorithm where every character is weighted by its position, starting with weight 1 for the right-most non-check digit character</value>
  </data>
  <data name="Modulus10_1AlgorithmName" xml:space="preserve">
    <value>Modulus10_1</value>
  </data>
  <data name="Modulus10_2AlgorithmDescription" xml:space="preserve">
    <value>Modulus 10 algorithm where every character is weighted by its position, starting with weight 2 for the right-most non-check digit character</value>
  </data>
  <data name="Modulus10_2AlgorithmName" xml:space="preserve">
    <value>Modulus10_2</value>
  </data>
  <data name="Modulus11AlgorithmDescription" xml:space="preserve">
    <value>Modulus 11 algorithm where every character is weighted by its position, starting from the right-most character. Generated check digit will be 0-9 or X</value>
  </data>
  <data name="Modulus11AlgorithmName" xml:space="preserve">
    <value>Modulus11</value>
  </data>
  <data name="ModulusIntModulusOutOfRangeMessage" xml:space="preserve">
    <value>Modulus must be &gt;= 2</value>
  </data>
  <data name="ModulusIntValueOutOfRangeMessageFormat" xml:space="preserve">
    <value>Value must be &gt;= 0 and &lt; {0}</value>
  </data>
  <data name="NcdAlgorithmDescription" xml:space="preserve">
    <value>NOID (Nice Opaque Identifier) check digit algorithm, betanumeric modulus 29</value>
  </data>
  <data name="NcdAlgorithmName" xml:space="preserve">
    <value>NOID Check Digit</value>
  </data>
  <data name="NhsAlgorithmDescription" xml:space="preserve">
    <value>NHS - Modulus 11, but only with check digits of 0-9</value>
  </data>
  <data name="NhsAlgorithmName" xml:space="preserve">
    <value>NHS (UK National Health Service)</value>
  </data>
  <data name="NpiAlgorithmDescription" xml:space="preserve">
    <value>NPI - Luhn algorithm with constant "80840" prefix</value>
  </data>
  <data name="NpiAlgorithmName" xml:space="preserve">
    <value>NPI (US National Provider Identifier)</value>
  </data>
  <data name="SedolAlgorithmDescription" xml:space="preserve">
    <value>SEDOL Algorithm</value>
  </data>
  <data name="SedolAlgorithmName" xml:space="preserve">
    <value>SEDOL</value>
  </data>
  <data name="String1" xml:space="preserve">
    <value />
  </data>
  <data name="VerhoeffAlgorithmDescription" xml:space="preserve">
    <value>Verhoeff's dihedral algorithm</value>
  </data>
  <data name="VerhoeffAlgorithmName" xml:space="preserve">
    <value>Verhoeff</value>
  </data>
  <data name="VinAlgorithmDescription" xml:space="preserve">
    <value>VIN Algorithm - weighted modulus 11 algorithm with transliteration of alphabetic characters</value>
  </data>
  <data name="VinAlgorithmName" xml:space="preserve">
    <value>VIN (Vehicle Identification Number)</value>
  </data>
  <data name="Modulus11DecimalAlgorithmDescription" xml:space="preserve">
    <value>Modulus 11 algorithm where every character is weighted by its position, starting from the right-most character. Generated check digit will be 0-9. Values that result in a check value of 10 are rejected</value>
  </data>
  <data name="Modulus11DecimalAlgorithmName" xml:space="preserve">
    <value>Modulus11Decimal</value>
  </data>
  <data name="Modulus11ExtendedAlgorithmDescription" xml:space="preserve">
    <value>Modulus 11 algorithm where every character is weighted by its position, starting from the right-most character. Generated check digit will be 0-9 or X</value>
  </data>
  <data name="Modulus11ExtendedAlgorithmName" xml:space="preserve">
    <value>Modulus11Extended</value>
  </data>
  <data name="Modulus11_27DecimalAlgorithmName" xml:space="preserve">
    <value>Modulus11_27Decimal</value>
  </data>
  <data name="Modulus11_27DecimalAlgorithmDescription" xml:space="preserve">
    <value>Modulus 11 algorithm uses repeating sequence of weights 2, 3, 4, 5, 6 and 7, starting from the right-most non-check digit character. Generated check digit will be 0-9. Values that result in a check value of 10 are rejected</value>
  </data>
  <data name="Modulus11_27ExtendedAlgorithmName" xml:space="preserve">
    <value>Modulus11_27Extended</value>
  </data>
  <data name="Modulus11_27ExtendedAlgorithmDescription" xml:space="preserve">
    <value>Modulus 11 algorithm uses repeating sequence of weights 2, 3, 4, 5, 6 and 7, starting from the right-most non-check digit character. Generated check digit will be 0-9 or X</value>
  </data>
</root>